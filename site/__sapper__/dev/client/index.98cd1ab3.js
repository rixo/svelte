import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, e as element, l as space, c as claim_element, a as children, b as detach_dev, p as claim_space, f as attr_dev, h as add_location, k as append_dev, j as insert_dev, w as mount_component, x as transition_in, y as transition_out, z as destroy_component } from './index.d7f76d54.js';
import './index.5e2a01ed.js';
import { D as Docs } from './index.e235fd0f.js';

/* src/routes/docs/index.svelte generated by Svelte v3.12.0 */

const file = "src/routes/docs/index.svelte";

function create_fragment(ctx) {
	var meta0, meta1, meta2, t, current;

	var docs = new Docs({
		props: { sections: ctx.sections },
		$$inline: true
	});

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t = space();
			docs.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			meta0 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta0_nodes = children(meta0);

			meta0_nodes.forEach(detach_dev);

			meta1 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta1_nodes = children(meta1);

			meta1_nodes.forEach(detach_dev);

			meta2 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta2_nodes = children(meta2);

			meta2_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			docs.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			document.title = "API Docs â€¢ Svelte";
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte API docs");
			add_location(meta0, file, 16, 1, 305);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", "Cybernetically enhanced web apps");
			add_location(meta1, file, 17, 1, 360);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", "Cybernetically enhanced web apps");
			add_location(meta2, file, 18, 1, 438);
		},

		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t, anchor);
			mount_component(docs, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var docs_changes = {};
			if (changed.sections) docs_changes.sections = ctx.sections;
			docs.$set(docs_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(docs.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(docs.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);

			if (detaching) {
				detach_dev(t);
			}

			destroy_component(docs, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

async function preload() {
	const sections = await this.fetch(`docs.json`).then(r => r.json());
	return { sections };
}

function instance($$self, $$props, $$invalidate) {
	let { sections } = $$props;

	const writable_props = ['sections'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
	};

	$$self.$capture_state = () => {
		return { sections };
	};

	$$self.$inject_state = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
	};

	return { sections };
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["sections"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.sections === undefined && !('sections' in props)) {
			console.warn("<Index> was created without expected prop 'sections'");
		}
	}

	get sections() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguOThjZDFhYjMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZG9jcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKCkge1xuXHRcdGNvbnN0IHNlY3Rpb25zID0gYXdhaXQgdGhpcy5mZXRjaChgZG9jcy5qc29uYCkudGhlbihyID0+IHIuanNvbigpKTtcblx0XHRyZXR1cm4geyBzZWN0aW9ucyB9O1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cblx0aW1wb3J0IHsgRG9jcyB9IGZyb20gJ0BzdmVsdGVqcy9zaXRlLWtpdCc7XG5cblx0ZXhwb3J0IGxldCBzZWN0aW9ucztcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5BUEkgRG9jcyDigKIgU3ZlbHRlPC90aXRsZT5cblxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjp0aXRsZVwiIGNvbnRlbnQ9XCJTdmVsdGUgQVBJIGRvY3NcIj5cblx0PG1ldGEgbmFtZT1cInR3aXR0ZXI6ZGVzY3JpcHRpb25cIiBjb250ZW50PVwiQ3liZXJuZXRpY2FsbHkgZW5oYW5jZWQgd2ViIGFwcHNcIj5cblx0PG1ldGEgbmFtZT1cIkRlc2NyaXB0aW9uXCIgY29udGVudD1cIkN5YmVybmV0aWNhbGx5IGVuaGFuY2VkIHdlYiBhcHBzXCI+XG48L3N2ZWx0ZTpoZWFkPlxuXG48RG9jcyB7c2VjdGlvbnN9Lz5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7eUJBcUJPLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cURBQVIsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFwQlAsZUFBZSxPQUFPLEdBQUc7Q0FDL0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0NBQ25FLE9BQU8sRUFBRSxRQUFRLEVBQUUsQ0FBQztDQUNwQjs7O0NBTU0sTUFBSSxvQkFBUSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
